Index: helper/gp.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/helper/gp.py b/benchmark/myhelper.py
rename from helper/gp.py
rename to benchmark/myhelper.py
--- a/helper/gp.py	
+++ b/benchmark/myhelper.py	
@@ -14,9 +14,14 @@
 
 import matplotlib.pyplot as plt
 
+MAX_FIT = 1000000
+MIN_FIT = -1000000
+
 
 # Define new functions
 def protectedDiv(left, right):
+    if right == 0:
+        return 1
     try:
         return left / right
     except ZeroDivisionError:
@@ -26,16 +31,39 @@
 def absLog(n):
     try:
         return math.log(math.fabs(n))
-    except ValueError:
+    except ValueError or OverflowError:
         return 1
 
+
 def protectedExp(x):
+    if math.fabs(x) > 8:
+        return 1
+    else:
+        return math.exp(x)
+
+
+def square(x):
     try:
-        return math.exp(x)
+        return x**2
+    except OverflowError:
+        return 1
+
+
+def cube(x):
+    try:
+        return x**3
     except OverflowError:
-        return 1000000
+        return 1
+
 
+def protectedSqrt(x):
+    if x < 0:
+        return 1
+    else:
+        return math.sqrt(x)
 
+
+### Initialize GP
 def initGP(toolbox, X, y, num_features, sample_size=None, limitDepth=None, limitSize=None, realData=False):
     """
     :param toolbox: toolbox used to init gp
@@ -48,8 +76,21 @@
     :param realData:
     :return: none
     """
+    # # Koza Set: +, -, *, %, sin, cos, exp, ln(|x|)
+    # pset = gp.PrimitiveSet("MAIN", 2)
+    # pset.addPrimitive(operator.add, 2)
+    # pset.addPrimitive(operator.sub, 2)
+    # pset.addPrimitive(operator.mul, 2)
+    # pset.addPrimitive(protectedDiv, 2)
+    # pset.addPrimitive(math.sin, 1)
+    # pset.addPrimitive(math.cos, 1)
+    # pset.addPrimitive(protectedExp, 1)
+    # pset.addPrimitive(absLog, 1)
+    # pset.renameArguments(ARG0='x')
+    # pset.renameArguments(ARG1='y')
+
     # Koza Set: +, -, *, %, sin, cos, exp, ln(|x|)
-    pset = gp.PrimitiveSet("MAIN", 2)
+    pset = gp.PrimitiveSet("MAIN", 5)
     pset.addPrimitive(operator.add, 2)
     pset.addPrimitive(operator.sub, 2)
     pset.addPrimitive(operator.mul, 2)
@@ -58,14 +99,26 @@
     pset.addPrimitive(math.cos, 1)
     pset.addPrimitive(protectedExp, 1)
     pset.addPrimitive(absLog, 1)
-    pset.renameArguments(ARG0='x')
-    pset.renameArguments(ARG1='y')
+    pset.addPrimitive(square, 1)
+    pset.addPrimitive(cube, 1)
+    pset.addPrimitive(math.tan, 1)
+    pset.addPrimitive(math.tanh, 1)
+    pset.addPrimitive(protectedSqrt, 1)
+    pset.addEphemeralConstant("rand64double", lambda: random.uniform(-1000, 1000))
+
+    pset.renameArguments(ARG0='x0')
+    pset.renameArguments(ARG1='x1')
+    pset.renameArguments(ARG2='x2')
+    pset.renameArguments(ARG3='x3')
+    pset.renameArguments(ARG4='x4')
+
 
     # Need weights to be same length as fitness data
     if sample_size is not None:
-        creator.create("FitnessMin", base.Fitness, weights=(-1.0,) * int(sample_size))
+        # creator.create("FitnessMin", base.Fitness, weights=(-1.0,) * int(sample_size))
+        creator.create("FitnessMin", base.Fitness, avalue=1, weights=(-1.0,) * int(sample_size))
     else:
-        creator.create("FitnessMin", base.Fitness, weights=(-1.0,) * len(X[0]))
+        creator.create("FitnessMin", base.Fitness, avalue=1, weights=(-1.0,) * len(X[0]))
 
     creator.create("Individual", gp.PrimitiveTree, fitness=creator.FitnessMin)
 
@@ -100,37 +153,10 @@
     # Transform the tree expression in a callable function
     func = toolbox.compile(expr=individual)
     # Evaluate the mean squared error between the expression
-    # TODO: ALOW FOR N-FEATURES BY PASSING X AS AN ARG LIST OR SOMETHING
-    # sqerrors = [(func(*X[i]) - y[i]) ** 2 for i in range(len(X))]
-    # sqerrors = [(func(x1, x2) - y([x1, x2])) ** 2 for x1, x2 in zip(X[0], X[1])]
-    sqerrors = [(func(x1, x2) - y(x1, x2)) ** 2 for x1, x2 in zip(X[0], X[1])]
-    # TODO: USE TO DEMONSTRATE DOWNSAMPLING
-    # print("Datapoints = " + str(X))
-    # print("Errors " + str(sqerrors))
+    sqerrors = [(func(*x) - y(*x)) ** 2 for x in X]
     return tuple(sqerrors)
 
 
-def lexAvg(tuples):
-    avgs = []
-    for t in tuples:
-        avgs.append(np.asarray(t).sum() / np.asarray(t).size)
-    return np.mean(np.asarray(avgs))
-
-
-def lexMed(tuples):
-    meds = []
-    for t in tuples:
-        meds.append(np.asarray(t).sum() / np.asarray(t).size)
-    return np.median(np.asarray(meds))
-
-
-def lexMin(tuples):
-    avgs = []
-    for t in tuples:
-        avgs.append(np.asarray(t).sum() / np.asarray(t).size)
-    return np.min(np.asarray(avgs))
-
-
 def dispHallOfFame(hof):
     print("HALL OF FAME ")
     counter = 0
@@ -139,39 +165,37 @@
         counter += 1
 
 
-def plotData(logbook, selection="tourn"):
+def plotData(logbook):
     """Plot data from log
 
     :param log:
     :return:
     """
+    fit_mins = logbook.select("min")
+    fit_meds = logbook.select("med")
     gen = logbook.select("gen")
-    if selection == "tourn":
-        fit_mins = logbook.chapters["fitness"].select("min")
-        fit = logbook.chapters["fitness"].select("avg")
-        size_avgs = logbook.chapters["size"].select("size avg")
-
-    elif selection == "elex":
-        fit_mins = logbook.chapters["fitness"].select("lex min")
-        fit_meds = logbook.chapters["fitness"].select("lex med")
-        size_avgs = logbook.chapters["size"].select("avg")
 
     fig, ax1 = plt.subplots()
     line1 = ax1.plot(gen, fit_mins, "b-", label="Minimum Fitness")
     ax1.set_xlabel("Generation")
-    ax1.set_ylabel("Fitness", color="b")
+    ax1.set_ylabel("Min Fitness", color="b")
     for tl in ax1.get_yticklabels():
         tl.set_color("b")
 
+    ax2 = ax1.twinx()
     line2 = ax1.plot(gen, fit_meds, "g-", label="Median Fitness")
+    ax2.set_ylabel("Med Fitness", color="g")
+    for tl in ax2.get_yticklabels():
+        tl.set_color("g")
 
-    ax3 = ax1.twinx()
-    line3 = ax3.plot(gen, size_avgs, "r-", label="Average Size")
-    ax3.set_ylabel("Size", color="r")
-    for tl in ax3.get_yticklabels():
-        tl.set_color("r")
+    # ax3 = ax1.twinx()
+    # line3 = ax3.plot(gen, size_avgs, "r-", label="Average Size")
+    # ax3.set_ylabel("Size", color="r")
+    # for tl in ax3.get_yticklabels():
+    #     tl.set_color("r")
 
-    lns = line1 + line2 + line3
+    lns = line1 + line2
+    # lns = line1 + line2 + line3
     labs = [l.get_label() for l in lns]
     ax1.legend(lns, labs, loc="center right")
 
