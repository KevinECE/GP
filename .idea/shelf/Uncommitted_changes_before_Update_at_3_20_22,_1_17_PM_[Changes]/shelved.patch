Index: benchmark/myhelper.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import logging\nimport operator\nimport math\nimport random\n\nimport numpy as np\n\nfrom deap import algorithms\nfrom deap import base\nfrom deap import creator\nfrom deap import tools\nfrom deap import gp\nfrom deap.benchmarks import gp as benchmark\n\nimport matplotlib.pyplot as plt\n\nMAX_FIT = 1000000\nMIN_FIT = -1000000\n\n\n# Define new functions\ndef protectedDiv(left, right):\n    if right == 0:\n        return 1\n    try:\n        return left / right\n    except ZeroDivisionError:\n        return 1\n\n\ndef absLog(n):\n    try:\n        return math.log(math.fabs(n))\n    except ValueError or OverflowError:\n        return 1\n\n\ndef protectedExp(x):\n    if math.fabs(x) > 8:\n        return 1\n    else:\n        return math.exp(x)\n\n\ndef square(x):\n    try:\n        return x**2\n    except OverflowError:\n        return 1\n\n\ndef cube(x):\n    try:\n        return x**3\n    except OverflowError:\n        return 1\n\n\ndef protectedSqrt(x):\n    if x < 0:\n        return 1\n    else:\n        return math.sqrt(x)\n\n\n### Initialize GP\ndef initGP(toolbox, X, y, num_features, sample_size=None, limitDepth=None, limitSize=None, realData=False):\n    \"\"\"\n    :param toolbox: toolbox used to init gp\n    :param X: independent variable(s)\n    :param y: dependent variables\n    :param num_features: number of independent variables in X\n    :param sample_size: number of samples to use\n    :param limitDepth: optionally set a limit on the max expression tree depth\n    :param limitSize: optionally set a limit on the max expression tree size\n    :param realData:\n    :return: none\n    \"\"\"\n    # # Koza Set: +, -, *, %, sin, cos, exp, ln(|x|)\n    # pset = gp.PrimitiveSet(\"MAIN\", 2)\n    # pset.addPrimitive(operator.add, 2)\n    # pset.addPrimitive(operator.sub, 2)\n    # pset.addPrimitive(operator.mul, 2)\n    # pset.addPrimitive(protectedDiv, 2)\n    # pset.addPrimitive(math.sin, 1)\n    # pset.addPrimitive(math.cos, 1)\n    # pset.addPrimitive(protectedExp, 1)\n    # pset.addPrimitive(absLog, 1)\n    # pset.renameArguments(ARG0='x')\n    # pset.renameArguments(ARG1='y')\n\n    # Koza Set: +, -, *, %, sin, cos, exp, ln(|x|)\n    pset = gp.PrimitiveSet(\"MAIN\", 5)\n    pset.addPrimitive(operator.add, 2)\n    pset.addPrimitive(operator.sub, 2)\n    pset.addPrimitive(operator.mul, 2)\n    pset.addPrimitive(protectedDiv, 2)\n    pset.addPrimitive(math.sin, 1)\n    pset.addPrimitive(math.cos, 1)\n    pset.addPrimitive(protectedExp, 1)\n    pset.addPrimitive(absLog, 1)\n    pset.addPrimitive(square, 1)\n    pset.addPrimitive(cube, 1)\n    pset.addPrimitive(math.tan, 1)\n    pset.addPrimitive(math.tanh, 1)\n    pset.addPrimitive(protectedSqrt, 1)\n    pset.addEphemeralConstant(\"rand64double\", lambda: random.uniform(-1000, 1000))\n\n    pset.renameArguments(ARG0='x0')\n    pset.renameArguments(ARG1='x1')\n    pset.renameArguments(ARG2='x2')\n    pset.renameArguments(ARG3='x3')\n    pset.renameArguments(ARG4='x4')\n\n\n    # Need weights to be same length as fitness data\n    if sample_size is not None:\n        # creator.create(\"FitnessMin\", base.Fitness, weights=(-1.0,) * int(sample_size))\n        creator.create(\"FitnessMin\", base.Fitness, avalue=1, weights=(-1.0,) * int(sample_size))\n    else:\n        creator.create(\"FitnessMin\", base.Fitness, avalue=1, weights=(-1.0,) * len(X[0]))\n\n    creator.create(\"Individual\", gp.PrimitiveTree, fitness=creator.FitnessMin)\n\n    toolbox.register(\"expr\", gp.genHalfAndHalf, pset=pset, min_=1, max_=2)\n    toolbox.register(\"individual\", tools.initIterate, creator.Individual, toolbox.expr)\n    toolbox.register(\"population\", tools.initRepeat, list, toolbox.individual)\n    toolbox.register(\"compile\", gp.compile, pset=pset)\n\n    toolbox.register(\"evaluate\", evalSymbReg, toolbox=toolbox, y=y, X=X)\n    toolbox.register(\"select\", tools.selAutomaticEpsilonLexicase)\n    toolbox.register(\"mate\", gp.cxOnePoint)\n    toolbox.register(\"expr_mut\", gp.genFull, min_=0, max_=2)\n    toolbox.register(\"mutate\", gp.mutUniform, expr=toolbox.expr_mut, pset=pset)\n\n    if limitDepth is not None:\n        toolbox.decorate(\"mate\", gp.staticLimit(key=operator.attrgetter(\"height\"), max_value=limitDepth))\n        toolbox.decorate(\"mutate\", gp.staticLimit(key=operator.attrgetter(\"height\"), max_value=limitDepth))\n    if limitSize is not None:\n        toolbox.decorate(\"mate\", gp.staticLimit(key=len, max_value=limitSize))\n        toolbox.decorate(\"mutate\", gp.staticLimit(key=len, max_value=limitSize))\n\n\ndef evalRealSymbReg(individual, samples, toolbox, X, y):\n    # Transform the tree expression in a callable function\n    func = toolbox.compile(expr=individual)\n    # Evaluate the mean squared error between the expression\n    sqerrors = [(func(x1, x2) - y) ** 2 for x1, x2 in zip(X[0], X[1])]\n    return tuple(sqerrors)\n\n\ndef evalSymbReg(individual, toolbox, X, y):\n    # Transform the tree expression in a callable function\n    func = toolbox.compile(expr=individual)\n    # Evaluate the mean squared error between the expression\n    try:\n        sqerrors = [(func(*x) - y(*x)) ** 2 for x in X]\n    except OverflowError:\n        sqerrors = [1000000000000000000000000000 for x in X]\n    return tuple(sqerrors)\n\n\ndef dispHallOfFame(hof):\n    print(\"HALL OF FAME \")\n    counter = 0\n    for h in hof:\n        print(str(counter) + \" \" + str(h))\n        counter += 1\n\n\ndef plotData(logbook):\n    \"\"\"Plot data from log\n\n    :param log:\n    :return:\n    \"\"\"\n    fit_mins = logbook.select(\"min\")\n    fit_meds = logbook.select(\"med\")\n    gen = logbook.select(\"gen\")\n\n    fig, ax1 = plt.subplots()\n    line1 = ax1.plot(gen, fit_mins, \"b-\", label=\"Minimum Fitness\")\n    ax1.set_xlabel(\"Generation\")\n    ax1.set_ylabel(\"Min Fitness\", color=\"b\")\n    for tl in ax1.get_yticklabels():\n        tl.set_color(\"b\")\n\n    ax2 = ax1.twinx()\n    line2 = ax1.plot(gen, fit_meds, \"g-\", label=\"Median Fitness\")\n    ax2.set_ylabel(\"Med Fitness\", color=\"g\")\n    for tl in ax2.get_yticklabels():\n        tl.set_color(\"g\")\n\n    # ax3 = ax1.twinx()\n    # line3 = ax3.plot(gen, size_avgs, \"r-\", label=\"Average Size\")\n    # ax3.set_ylabel(\"Size\", color=\"r\")\n    # for tl in ax3.get_yticklabels():\n    #     tl.set_color(\"r\")\n\n    lns = line1 + line2\n    # lns = line1 + line2 + line3\n    labs = [l.get_label() for l in lns]\n    ax1.legend(lns, labs, loc=\"center right\")\n\n    plt.show()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/benchmark/myhelper.py b/benchmark/myhelper.py
--- a/benchmark/myhelper.py	(revision 9b07e18276b7d69099acd63c4ecf4494b6be638b)
+++ b/benchmark/myhelper.py	(date 1647452808983)
@@ -156,7 +156,7 @@
     try:
         sqerrors = [(func(*x) - y(*x)) ** 2 for x in X]
     except OverflowError:
-        sqerrors = [1000000000000000000000000000 for x in X]
+        sqerrors = [10**26 for x in X]
     return tuple(sqerrors)
 
 
Index: benchmark/korns-7_ds.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from benchmark.myhelper import *\nimport pandas as pd\n\nDATA_MAX = 50\nDATA_MIN = -50\n# STEP_SIZE = 0.4\nDATA_SIZE = 1000\nNUM_FEATURES = 5\n\nSAMPLE_SIZE = DATA_SIZE // 5\n\n\n# Pagie 1 Function\ndef pagie1(x, y):\n    if x == 0 and y == 0:\n        return 0\n    elif x == 0:\n        return 1 / (1 + pow(y, -4))\n    elif y == 0:\n        return 1 / (1 + pow(x, -4))\n    else:\n        return 1 / (1 + pow(x, -4)) + 1 / (1 + pow(y, -4))\n\n\n# Pagie 1 Function\ndef korns7(x0, x1, x2, x3, x4):\n    return 213.80940889 * (1 - math.exp(-0.54723748542 * x0))\n\n\ndef test(toolbox, ind, X, y):\n    func = toolbox.compile(expr=ind)\n    sqerrors = [(func(*x) - y(*x)) ** 2 for x in X]\n    df_log = pd.DataFrame(sqerrors)\n    df_log.to_csv('..\\hoftest.csv', index=False)\n    print(np.mean(sqerrors))\n\n\ndef main():\n    random.seed()\n    toolbox = base.Toolbox()\n\n    # DATAa\n    X = np.transpose(\n        [np.around(np.random.uniform(DATA_MIN, DATA_MAX, int(DATA_SIZE)), 1).tolist() for row in range(NUM_FEATURES)])\n    print(X)\n    # print(\"Sample size \" + str(SAMPLE_SIZE))\n    y = korns7\n\n    # GP\n    initGP(toolbox, X, y, num_features=NUM_FEATURES, sample_size=SAMPLE_SIZE, limitDepth=10, limitSize=15)\n\n    # POP\n    pop = toolbox.population(n=1000)\n\n    # STATS\n    hof = tools.HallOfFame(5)\n    stats_fit = tools.Statistics(lambda ind: ind.fitness.avalue)\n    stats_size = tools.Statistics(len)\n    mstats = tools.MultiStatistics(fitness=stats_fit, size=stats_size)\n    stats_fit.register(\"med\", np.median, axis=0)\n    stats_fit.register(\"min\", np.min, axis=0)\n    stats_size.register(\"size avg\", np.mean)\n\n    # RUN\n    pop, logbook = algorithms.gpDownsample(pop, toolbox, X, y, SAMPLE_SIZE, 0.7, 0.3, 100, stats=stats_fit,\n                                           halloffame=hof, verbose=True)\n    # Display hall of fame\n    dispHallOfFame(hof)\n    for h in hof:\n        test(toolbox, h, X, y)\n\n    # Log data to csv\n    df_log = pd.DataFrame(logbook)\n    df_log.to_csv('..\\data.csv', index=False)\n\n    # Plot data\n    plotData(logbook)\n\n\nif __name__ == \"__main__\":\n    main()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/benchmark/korns-7_ds.py b/benchmark/korns-7_ds.py
--- a/benchmark/korns-7_ds.py	(revision 9b07e18276b7d69099acd63c4ecf4494b6be638b)
+++ b/benchmark/korns-7_ds.py	(date 1647453313816)
@@ -7,7 +7,7 @@
 DATA_SIZE = 1000
 NUM_FEATURES = 5
 
-SAMPLE_SIZE = DATA_SIZE // 5
+SAMPLE_SIZE = int(DATA_SIZE * .15)
 
 
 # Pagie 1 Function
Index: deap/algorithms.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#    This file is part of DEAP.\n#\n#    DEAP is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU Lesser General Public License as\n#    published by the Free Software Foundation, either version 3 of\n#    the License, or (at your option) any later version.\n#\n#    DEAP is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n#    GNU Lesser General Public License for more details.\n#\n#    You should have received a copy of the GNU Lesser General Public\n#    License along with DEAP. If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"The :mod:`algorithms` module is intended to contain some specific algorithms\nin order to execute very common evolutionary algorithms. The method used here\nare more for convenience than reference as the implementation of every\nevolutionary algorithm may vary infinitely. Most of the algorithms in this\nmodule use operators registered in the toolbox. Generally, the keyword used are\n:meth:`mate` for crossover, :meth:`mutate` for mutation, :meth:`~deap.select`\nfor selection and :meth:`evaluate` for evaluation.\n\nYou are encouraged to write your own algorithms in order to make them do what\nyou really want them to do.\n\"\"\"\n\nimport random\nimport numpy as np\nfrom functools import partial\n\nfrom . import tools\n\ndef gpDownsample(population, toolbox, X, y, sample_size, cxpb, mutpb, ngen, stats=None,\n             halloffame=None, verbose=__debug__):\n    \"\"\" Custom function to perform downsampled epsilon lexicase selection\n\n    :param population: A list of individuals.\n    :param toolbox: A :class:`~deap.base.Toolbox` that contains the evolution\n                    operators.\n    :param X: Independent variable data\n    :param y: Dependent variable data\n    :param cxpb: The probability of mating two individuals.\n    :param mutpb: The probability of mutating an individual.\n    :param ngen: The number of generation.\n    :param stats: A :class:`~deap.tools.Statistics` object that is updated\n                  inplace, optional.\n    :param halloffame: A :class:`~deap.tools.HallOfFame` object that will\n                       contain the best individuals, optional.\n    :param verbose: Whether or not to log the statistics.\n    :returns: The final population\n    :returns: A class:`~deap.tools.Logbook` with the statistics of the\n              evolution\n    \"\"\"\n    logbook = tools.Logbook()\n    logbook.header = ['gen', 'nevals'] + (stats.fields if stats else [])\n\n    # Evaluate all cases to calculate aggregate fitness\n    fitnesses = toolbox.map(partial(toolbox.evaluate, X=X), population)\n    for ind, fit in zip(population, fitnesses):\n        ind.fitness.avalue = np.mean(np.asfarray(fit))\n\n    # Downsample cases\n    print(len(X))\n    print(sample_size)\n    indices = random.sample(list(range(0, len(X))), sample_size)\n    ds_X = np.array(X)[indices].tolist()\n    print(\"DOWNSAMPLED \" + str(ds_X))\n\n\n    # Evaluate downsampled cases\n    ds_fitnesses = toolbox.map(partial(toolbox.evaluate, X=ds_X), population)\n    for ind, fit in zip(population, ds_fitnesses):\n        ind.fitness.values = fit\n\n    # Update hall of fame\n    if halloffame is not None:\n        halloffame.update(population)\n    # Compile stats\n    record = stats.compile(population) if stats else {}\n    logbook.record(gen=0, nevals=sample_size*len(population), **record)\n    if verbose:\n        print(logbook.stream)\n\n    # Begin the generational process\n    for gen in range(1, ngen + 1):\n        # Select the next generation individuals\n        offspring = toolbox.select(population, len(population))\n\n        # Vary the pool of individuals\n        offspring = varAnd(offspring, toolbox, cxpb, mutpb)\n\n        # Evaluate all cases to calculate aggregate fitness\n        fitnesses = toolbox.map(partial(toolbox.evaluate, X=X), offspring)\n        for ind, fit in zip(offspring, fitnesses):\n            ind.fitness.avalue = np.mean(np.asfarray(fit))\n\n        # Downsample cases\n        indices = random.sample(list(range(0, len(X))), sample_size)\n        ds_X = np.array(X)[indices].tolist()\n\n        # Evaluate downsampled cases\n        ds_fitnesses = toolbox.map(partial(toolbox.evaluate, X=ds_X), offspring)\n        for ind, fit in zip(offspring, ds_fitnesses):\n            ind.fitness.values = fit\n\n        # Update the hall of fame with the generated individuals\n        if halloffame is not None:\n            halloffame.update(offspring)\n\n        # Replace the current population by the offspring\n        population[:] = offspring\n\n        # Append the current generation statistics to the logbook\n        record = stats.compile(population) if stats else {}\n        logbook.record(gen=gen, nevals=sample_size*len(population), **record)\n        if verbose:\n            print(logbook.stream)\n\n    return population, logbook\n\n\ndef varAnd(population, toolbox, cxpb, mutpb):\n    \"\"\"Part of an evolutionary algorithm applying only the variation part\n    (crossover **and** mutation). The modified individuals have their\n    fitness invalidated. The individuals are cloned so returned population is\n    independent of the input population\n\n    :param population: A list of individuals to vary.\n    :param toolbox: A :class:`~deap.base.Toolbox` that contains the evolution\n                    operators.\n    :param cxpb: The probability of mating two individuals.\n    :param mutpb: The probability of mutating an individual.\n    :returns: A list of varied individuals that are independent of their\n              parents.\n\n    The variation goes as follow. First, the parental population\n    :math:`P_\\mathrm{p}` is duplicated using the :meth:`toolbox.clone` method\n    and the result is put into the offspring population :math:`P_\\mathrm{o}`.  A\n    first loop over :math:`P_\\mathrm{o}` is executed to mate pairs of\n    consecutive individuals. According to the crossover probability *cxpb*, the\n    individuals :math:`\\mathbf{x}_i` and :math:`\\mathbf{x}_{i+1}` are mated\n    using the :meth:`toolbox.mate` method. The resulting children\n    :math:`\\mathbf{y}_i` and :math:`\\mathbf{y}_{i+1}` replace their respective\n    parents in :math:`P_\\mathrm{o}`. A second loop over the resulting\n    :math:`P_\\mathrm{o}` is executed to mutate every individual with a\n    probability *mutpb*. When an individual is mutated it replaces its not\n    mutated version in :math:`P_\\mathrm{o}`. The resulting :math:`P_\\mathrm{o}`\n    is returned.\n\n    This variation is named *And* because of its propensity to apply both\n    crossover and mutation on the individuals. Note that both operators are\n    not applied systematically, the resulting individuals can be generated from\n    crossover only, mutation only, crossover and mutation, and reproduction\n    according to the given probabilities. Both probabilities should be in\n    :math:`[0, 1]`.\n    \"\"\"\n    offspring = [toolbox.clone(ind) for ind in population]\n\n    # Apply crossover and mutation on the offspring\n    for i in range(1, len(offspring), 2):\n        if random.random() < cxpb:\n            offspring[i - 1], offspring[i] = toolbox.mate(offspring[i - 1],\n                                                          offspring[i])\n            del offspring[i - 1].fitness.values, offspring[i].fitness.values\n\n    for i in range(len(offspring)):\n        if random.random() < mutpb:\n            offspring[i], = toolbox.mutate(offspring[i])\n            del offspring[i].fitness.values\n\n    return offspring\n\n\ndef eaSimple(population, toolbox, cxpb, mutpb, ngen, stats=None,\n             halloffame=None, verbose=__debug__):\n    \"\"\"This algorithm reproduce the simplest evolutionary algorithm as\n    presented in chapter 7 of [Back2000]_.\n\n    :param population: A list of individuals.\n    :param toolbox: A :class:`~deap.base.Toolbox` that contains the evolution\n                    operators.\n    :param cxpb: The probability of mating two individuals.\n    :param mutpb: The probability of mutating an individual.\n    :param ngen: The number of generation.\n    :param stats: A :class:`~deap.tools.Statistics` object that is updated\n                  inplace, optional.\n    :param halloffame: A :class:`~deap.tools.HallOfFame` object that will\n                       contain the best individuals, optional.\n    :param verbose: Whether or not to log the statistics.\n    :returns: The final population\n    :returns: A class:`~deap.tools.Logbook` with the statistics of the\n              evolution\n\n    The algorithm takes in a population and evolves it in place using the\n    :meth:`varAnd` method. It returns the optimized population and a\n    :class:`~deap.tools.Logbook` with the statistics of the evolution. The\n    logbook will contain the generation number, the number of evaluations for\n    each generation and the statistics if a :class:`~deap.tools.Statistics` is\n    given as argument. The *cxpb* and *mutpb* arguments are passed to the\n    :func:`varAnd` function. The pseudocode goes as follow ::\n\n        evaluate(population)\n        for g in range(ngen):\n            population = select(population, len(population))\n            offspring = varAnd(population, toolbox, cxpb, mutpb)\n            evaluate(offspring)\n            population = offspring\n\n    As stated in the pseudocode above, the algorithm goes as follow. First, it\n    evaluates the individuals with an invalid fitness. Second, it enters the\n    generational loop where the selection procedure is applied to entirely\n    replace the parental population. The 1:1 replacement ratio of this\n    algorithm **requires** the selection procedure to be stochastic and to\n    select multiple times the same individual, for example,\n    :func:`~deap.tools.selTournament` and :func:`~deap.tools.selRoulette`.\n    Third, it applies the :func:`varAnd` function to produce the next\n    generation population. Fourth, it evaluates the new individuals and\n    compute the statistics on this population. Finally, when *ngen*\n    generations are done, the algorithm returns a tuple with the final\n    population and a :class:`~deap.tools.Logbook` of the evolution.\n\n    .. note::\n\n        Using a non-stochastic selection method will result in no selection as\n        the operator selects *n* individuals from a pool of *n*.\n\n    This function expects the :meth:`toolbox.mate`, :meth:`toolbox.mutate`,\n    :meth:`toolbox.select` and :meth:`toolbox.evaluate` aliases to be\n    registered in the toolbox.\n\n    .. [Back2000] Back, Fogel and Michalewicz, \"Evolutionary Computation 1 :\n       Basic Algorithms and Operators\", 2000.\n    \"\"\"\n    logbook = tools.Logbook()\n    logbook.header = ['gen', 'nevals'] + (stats.fields if stats else [])\n\n    # Evaluate the individuals with an invalid fitness\n    invalid_ind = [ind for ind in population if not ind.fitness.valid]\n    fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)\n    for ind, fit in zip(invalid_ind, fitnesses):\n        ind.fitness.values = fit\n\n    if halloffame is not None:\n        halloffame.update(population)\n\n    record = stats.compile(population) if stats else {}\n    logbook.record(gen=0, nevals=len(invalid_ind), **record)\n    if verbose:\n        print(logbook.stream)\n\n    # Begin the generational process\n    for gen in range(1, ngen + 1):\n        # Select the next generation individuals\n        offspring = toolbox.select(population, len(population))\n\n        # Vary the pool of individuals\n        offspring = varAnd(offspring, toolbox, cxpb, mutpb)\n\n        # Evaluate the individuals with an invalid fitness\n        invalid_ind = [ind for ind in offspring if not ind.fitness.valid]\n        fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)\n        for ind, fit in zip(invalid_ind, fitnesses):\n            ind.fitness.values = fit\n\n        # Update the hall of fame with the generated individuals\n        if halloffame is not None:\n            halloffame.update(offspring)\n\n        # Replace the current population by the offspring\n        population[:] = offspring\n\n        # Append the current generation statistics to the logbook\n        record = stats.compile(population) if stats else {}\n        logbook.record(gen=gen, nevals=len(invalid_ind), **record)\n        if verbose:\n            print(logbook.stream)\n\n    return population, logbook\n\ndef varOr(population, toolbox, lambda_, cxpb, mutpb):\n    \"\"\"Part of an evolutionary algorithm applying only the variation part\n    (crossover, mutation **or** reproduction). The modified individuals have\n    their fitness invalidated. The individuals are cloned so returned\n    population is independent of the input population.\n\n    :param population: A list of individuals to vary.\n    :param toolbox: A :class:`~deap.base.Toolbox` that contains the evolution\n                    operators.\n    :param lambda\\_: The number of children to produce\n    :param cxpb: The probability of mating two individuals.\n    :param mutpb: The probability of mutating an individual.\n    :returns: The final population.\n\n    The variation goes as follow. On each of the *lambda_* iteration, it\n    selects one of the three operations; crossover, mutation or reproduction.\n    In the case of a crossover, two individuals are selected at random from\n    the parental population :math:`P_\\mathrm{p}`, those individuals are cloned\n    using the :meth:`toolbox.clone` method and then mated using the\n    :meth:`toolbox.mate` method. Only the first child is appended to the\n    offspring population :math:`P_\\mathrm{o}`, the second child is discarded.\n    In the case of a mutation, one individual is selected at random from\n    :math:`P_\\mathrm{p}`, it is cloned and then mutated using using the\n    :meth:`toolbox.mutate` method. The resulting mutant is appended to\n    :math:`P_\\mathrm{o}`. In the case of a reproduction, one individual is\n    selected at random from :math:`P_\\mathrm{p}`, cloned and appended to\n    :math:`P_\\mathrm{o}`.\n\n    This variation is named *Or* because an offspring will never result from\n    both operations crossover and mutation. The sum of both probabilities\n    shall be in :math:`[0, 1]`, the reproduction probability is\n    1 - *cxpb* - *mutpb*.\n    \"\"\"\n    assert (cxpb + mutpb) <= 1.0, (\n        \"The sum of the crossover and mutation probabilities must be smaller \"\n        \"or equal to 1.0.\")\n\n    offspring = []\n    for _ in range(lambda_):\n        op_choice = random.random()\n        if op_choice < cxpb:            # Apply crossover\n            ind1, ind2 = list(map(toolbox.clone, random.sample(population, 2)))\n            ind1, ind2 = toolbox.mate(ind1, ind2)\n            del ind1.fitness.values\n            offspring.append(ind1)\n        elif op_choice < cxpb + mutpb:  # Apply mutation\n            ind = toolbox.clone(random.choice(population))\n            ind, = toolbox.mutate(ind)\n            del ind.fitness.values\n            offspring.append(ind)\n        else:                           # Apply reproduction\n            offspring.append(random.choice(population))\n\n    return offspring\n\n\ndef eaMuPlusLambda(population, toolbox, mu, lambda_, cxpb, mutpb, ngen,\n                   stats=None, halloffame=None, verbose=__debug__):\n    \"\"\"This is the :math:`(\\mu + \\lambda)` evolutionary algorithm.\n\n    :param population: A list of individuals.\n    :param toolbox: A :class:`~deap.base.Toolbox` that contains the evolution\n                    operators.\n    :param mu: The number of individuals to select for the next generation.\n    :param lambda\\_: The number of children to produce at each generation.\n    :param cxpb: The probability that an offspring is produced by crossover.\n    :param mutpb: The probability that an offspring is produced by mutation.\n    :param ngen: The number of generation.\n    :param stats: A :class:`~deap.tools.Statistics` object that is updated\n                  inplace, optional.\n    :param halloffame: A :class:`~deap.tools.HallOfFame` object that will\n                       contain the best individuals, optional.\n    :param verbose: Whether or not to log the statistics.\n    :returns: The final population\n    :returns: A class:`~deap.tools.Logbook` with the statistics of the\n              evolution.\n\n    The algorithm takes in a population and evolves it in place using the\n    :func:`varOr` function. It returns the optimized population and a\n    :class:`~deap.tools.Logbook` with the statistics of the evolution. The\n    logbook will contain the generation number, the number of evaluations for\n    each generation and the statistics if a :class:`~deap.tools.Statistics` is\n    given as argument. The *cxpb* and *mutpb* arguments are passed to the\n    :func:`varOr` function. The pseudocode goes as follow ::\n\n        evaluate(population)\n        for g in range(ngen):\n            offspring = varOr(population, toolbox, lambda_, cxpb, mutpb)\n            evaluate(offspring)\n            population = select(population + offspring, mu)\n\n    First, the individuals having an invalid fitness are evaluated. Second,\n    the evolutionary loop begins by producing *lambda_* offspring from the\n    population, the offspring are generated by the :func:`varOr` function. The\n    offspring are then evaluated and the next generation population is\n    selected from both the offspring **and** the population. Finally, when\n    *ngen* generations are done, the algorithm returns a tuple with the final\n    population and a :class:`~deap.tools.Logbook` of the evolution.\n\n    This function expects :meth:`toolbox.mate`, :meth:`toolbox.mutate`,\n    :meth:`toolbox.select` and :meth:`toolbox.evaluate` aliases to be\n    registered in the toolbox. This algorithm uses the :func:`varOr`\n    variation.\n    \"\"\"\n    logbook = tools.Logbook()\n    logbook.header = ['gen', 'nevals'] + (stats.fields if stats else [])\n\n    # Evaluate the individuals with an invalid fitness\n    invalid_ind = [ind for ind in population if not ind.fitness.valid]\n    fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)\n    for ind, fit in zip(invalid_ind, fitnesses):\n        ind.fitness.values = fit\n\n    if halloffame is not None:\n        halloffame.update(population)\n\n    record = stats.compile(population) if stats is not None else {}\n    logbook.record(gen=0, nevals=len(invalid_ind), **record)\n    if verbose:\n        print(logbook.stream)\n\n    # Begin the generational process\n    for gen in range(1, ngen + 1):\n        # Vary the population\n        offspring = varOr(population, toolbox, lambda_, cxpb, mutpb)\n\n        # Evaluate the individuals with an invalid fitness\n        invalid_ind = [ind for ind in offspring if not ind.fitness.valid]\n        fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)\n        for ind, fit in zip(invalid_ind, fitnesses):\n            ind.fitness.values = fit\n\n        # Update the hall of fame with the generated individuals\n        if halloffame is not None:\n            halloffame.update(offspring)\n\n        # Select the next generation population\n        population[:] = toolbox.select(population + offspring, mu)\n\n        # Update the statistics with the new population\n        record = stats.compile(population) if stats is not None else {}\n        logbook.record(gen=gen, nevals=len(invalid_ind), **record)\n        if verbose:\n            print(logbook.stream)\n\n    return population, logbook\n\n\ndef eaMuCommaLambda(population, toolbox, mu, lambda_, cxpb, mutpb, ngen,\n                    stats=None, halloffame=None, verbose=__debug__):\n    \"\"\"This is the :math:`(\\mu~,~\\lambda)` evolutionary algorithm.\n\n    :param population: A list of individuals.\n    :param toolbox: A :class:`~deap.base.Toolbox` that contains the evolution\n                    operators.\n    :param mu: The number of individuals to select for the next generation.\n    :param lambda\\_: The number of children to produce at each generation.\n    :param cxpb: The probability that an offspring is produced by crossover.\n    :param mutpb: The probability that an offspring is produced by mutation.\n    :param ngen: The number of generation.\n    :param stats: A :class:`~deap.tools.Statistics` object that is updated\n                  inplace, optional.\n    :param halloffame: A :class:`~deap.tools.HallOfFame` object that will\n                       contain the best individuals, optional.\n    :param verbose: Whether or not to log the statistics.\n    :returns: The final population\n    :returns: A class:`~deap.tools.Logbook` with the statistics of the\n              evolution\n\n    The algorithm takes in a population and evolves it in place using the\n    :func:`varOr` function. It returns the optimized population and a\n    :class:`~deap.tools.Logbook` with the statistics of the evolution. The\n    logbook will contain the generation number, the number of evaluations for\n    each generation and the statistics if a :class:`~deap.tools.Statistics` is\n    given as argument. The *cxpb* and *mutpb* arguments are passed to the\n    :func:`varOr` function. The pseudocode goes as follow ::\n\n        evaluate(population)\n        for g in range(ngen):\n            offspring = varOr(population, toolbox, lambda_, cxpb, mutpb)\n            evaluate(offspring)\n            population = select(offspring, mu)\n\n    First, the individuals having an invalid fitness are evaluated. Second,\n    the evolutionary loop begins by producing *lambda_* offspring from the\n    population, the offspring are generated by the :func:`varOr` function. The\n    offspring are then evaluated and the next generation population is\n    selected from **only** the offspring. Finally, when\n    *ngen* generations are done, the algorithm returns a tuple with the final\n    population and a :class:`~deap.tools.Logbook` of the evolution.\n\n    .. note::\n\n        Care must be taken when the lambda:mu ratio is 1 to 1 as a\n        non-stochastic selection will result in no selection at all as the\n        operator selects *lambda* individuals from a pool of *mu*.\n\n\n    This function expects :meth:`toolbox.mate`, :meth:`toolbox.mutate`,\n    :meth:`toolbox.select` and :meth:`toolbox.evaluate` aliases to be\n    registered in the toolbox. This algorithm uses the :func:`varOr`\n    variation.\n    \"\"\"\n    assert lambda_ >= mu, \"lambda must be greater or equal to mu.\"\n\n    # Evaluate the individuals with an invalid fitness\n    invalid_ind = [ind for ind in population if not ind.fitness.valid]\n    fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)\n    for ind, fit in zip(invalid_ind, fitnesses):\n        ind.fitness.values = fit\n\n    if halloffame is not None:\n        halloffame.update(population)\n\n    logbook = tools.Logbook()\n    logbook.header = ['gen', 'nevals'] + (stats.fields if stats else [])\n\n    record = stats.compile(population) if stats is not None else {}\n    logbook.record(gen=0, nevals=len(invalid_ind), **record)\n    if verbose:\n        print(logbook.stream)\n\n    # Begin the generational process\n    for gen in range(1, ngen + 1):\n        # Vary the population\n        offspring = varOr(population, toolbox, lambda_, cxpb, mutpb)\n\n        # Evaluate the individuals with an invalid fitness\n        invalid_ind = [ind for ind in offspring if not ind.fitness.valid]\n        fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)\n        for ind, fit in zip(invalid_ind, fitnesses):\n            ind.fitness.values = fit\n\n        # Update the hall of fame with the generated individuals\n        if halloffame is not None:\n            halloffame.update(offspring)\n\n        # Select the next generation population\n        population[:] = toolbox.select(offspring, mu)\n\n        # Update the statistics with the new population\n        record = stats.compile(population) if stats is not None else {}\n        logbook.record(gen=gen, nevals=len(invalid_ind), **record)\n        if verbose:\n            print(logbook.stream)\n    return population, logbook\n\n\ndef eaGenerateUpdate(toolbox, ngen, halloffame=None, stats=None,\n                     verbose=__debug__):\n    \"\"\"This is algorithm implements the ask-tell model proposed in\n    [Colette2010]_, where ask is called `generate` and tell is called `update`.\n\n    :param toolbox: A :class:`~deap.base.Toolbox` that contains the evolution\n                    operators.\n    :param ngen: The number of generation.\n    :param stats: A :class:`~deap.tools.Statistics` object that is updated\n                  inplace, optional.\n    :param halloffame: A :class:`~deap.tools.HallOfFame` object that will\n                       contain the best individuals, optional.\n    :param verbose: Whether or not to log the statistics.\n    :returns: The final population\n    :returns: A class:`~deap.tools.Logbook` with the statistics of the\n              evolution\n\n    The algorithm generates the individuals using the :func:`toolbox.generate`\n    function and updates the generation method with the :func:`toolbox.update`\n    function. It returns the optimized population and a\n    :class:`~deap.tools.Logbook` with the statistics of the evolution. The\n    logbook will contain the generation number, the number of evaluations for\n    each generation and the statistics if a :class:`~deap.tools.Statistics` is\n    given as argument. The pseudocode goes as follow ::\n\n        for g in range(ngen):\n            population = toolbox.generate()\n            evaluate(population)\n            toolbox.update(population)\n\n    .. [Colette2010] Collette, Y., N. Hansen, G. Pujol, D. Salazar Aponte and\n       R. Le Riche (2010). On Object-Oriented Programming of Optimizers -\n       Examples in Scilab. In P. Breitkopf and R. F. Coelho, eds.:\n       Multidisciplinary Design Optimization in Computational Mechanics,\n       Wiley, pp. 527-565;\n\n    \"\"\"\n    logbook = tools.Logbook()\n    logbook.header = ['gen', 'nevals'] + (stats.fields if stats else [])\n\n    for gen in range(ngen):\n        # Generate a new population\n        population = toolbox.generate()\n        # Evaluate the individuals\n        fitnesses = toolbox.map(toolbox.evaluate, population)\n        for ind, fit in zip(population, fitnesses):\n            ind.fitness.values = fit\n\n        if halloffame is not None:\n            halloffame.update(population)\n\n        # Update the strategy with the evaluated individuals\n        toolbox.update(population)\n\n        record = stats.compile(population) if stats is not None else {}\n        logbook.record(gen=gen, nevals=len(population), **record)\n        if verbose:\n            print(logbook.stream)\n\n    return population, logbook\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/deap/algorithms.py b/deap/algorithms.py
--- a/deap/algorithms.py	(revision 9b07e18276b7d69099acd63c4ecf4494b6be638b)
+++ b/deap/algorithms.py	(date 1647452758571)
@@ -241,9 +241,10 @@
     for ind, fit in zip(invalid_ind, fitnesses):
         ind.fitness.values = fit
 
+    # Update hall of fame
     if halloffame is not None:
         halloffame.update(population)
-
+    # Compile stats
     record = stats.compile(population) if stats else {}
     logbook.record(gen=0, nevals=len(invalid_ind), **record)
     if verbose:
Index: deap/tools/support.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\n\ntry:\n    import pickle as pickle\nexcept ImportError:\n    import pickle\n\nfrom bisect import bisect_right\nfrom collections import defaultdict\nfrom copy import deepcopy\nfrom functools import partial\nfrom itertools import chain\nfrom operator import eq\n\n\ndef identity(obj):\n    \"\"\"Returns directly the argument *obj*.\n    \"\"\"\n    return obj\n\nclass History(object):\n    \"\"\"The :class:`History` class helps to build a genealogy of all the\n    individuals produced in the evolution. It contains two attributes,\n    the :attr:`genealogy_tree` that is a dictionary of lists indexed by\n    individual, the list contain the indices of the parents. The second\n    attribute :attr:`genealogy_history` contains every individual indexed\n    by their individual number as in the genealogy tree.\n\n    The produced genealogy tree is compatible with `NetworkX\n    <http://networkx.lanl.gov/index.html>`_, here is how to plot the genealogy\n    tree ::\n\n        history = History()\n\n        # Decorate the variation operators\n        toolbox.decorate(\"mate\", history.decorator)\n        toolbox.decorate(\"mutate\", history.decorator)\n\n        # Create the population and populate the history\n        population = toolbox.population(n=POPSIZE)\n        history.update(population)\n\n        # Do the evolution, the decorators will take care of updating the\n        # history\n        # [...]\n\n        import matplotlib.pyplot as plt\n        import networkx\n\n        graph = networkx.DiGraph(history.genealogy_tree)\n        graph = graph.reverse()     # Make the grah top-down\n        colors = [toolbox.evaluate(history.genealogy_history[i])[0] for i in graph]\n        networkx.draw(graph, node_color=colors)\n        plt.show()\n\n    Using NetworkX in combination with `pygraphviz\n    <http://networkx.lanl.gov/pygraphviz/>`_ (dot layout) this amazing\n    genealogy tree can be obtained from the OneMax example with a population\n    size of 20 and 5 generations, where the color of the nodes indicate there\n    fitness, blue is low and red is high.\n\n    .. image:: /_images/genealogy.png\n       :width: 67%\n\n    .. note::\n       The genealogy tree might get very big if your population and/or the\n       number of generation is large.\n\n    \"\"\"\n    def __init__(self):\n        self.genealogy_index = 0\n        self.genealogy_history = dict()\n        self.genealogy_tree = dict()\n\n    def update(self, individuals):\n        \"\"\"Update the history with the new *individuals*. The index present in\n        their :attr:`history_index` attribute will be used to locate their\n        parents, it is then modified to a unique one to keep track of those\n        new individuals. This method should be called on the individuals after\n        each variation.\n\n        :param individuals: The list of modified individuals that shall be\n                            inserted in the history.\n\n        If the *individuals* do not have a :attr:`history_index` attribute,\n        the attribute is added and this individual is considered as having no\n        parent. This method should be called with the initial population to\n        initialize the history.\n\n        Modifying the internal :attr:`genealogy_index` of the history or the\n        :attr:`history_index` of an individual may lead to unpredictable\n        results and corruption of the history.\n        \"\"\"\n        try:\n            parent_indices = tuple(ind.history_index for ind in individuals)\n        except AttributeError:\n            parent_indices = tuple()\n\n        for ind in individuals:\n            self.genealogy_index += 1\n            ind.history_index = self.genealogy_index\n            self.genealogy_history[self.genealogy_index] = deepcopy(ind)\n            self.genealogy_tree[self.genealogy_index] = parent_indices\n\n    @property\n    def decorator(self):\n        \"\"\"Property that returns an appropriate decorator to enhance the\n        operators of the toolbox. The returned decorator assumes that the\n        individuals are returned by the operator. First the decorator calls\n        the underlying operation and then calls the :func:`update` function\n        with what has been returned by the operator. Finally, it returns the\n        individuals with their history parameters modified according to the\n        update function.\n        \"\"\"\n        def decFunc(func):\n            def wrapFunc(*args, **kargs):\n                individuals = func(*args, **kargs)\n                self.update(individuals)\n                return individuals\n            return wrapFunc\n        return decFunc\n\n    def getGenealogy(self, individual, max_depth=float(\"inf\")):\n        \"\"\"Provide the genealogy tree of an *individual*. The individual must\n        have an attribute :attr:`history_index` as defined by\n        :func:`~deap.tools.History.update` in order to retrieve its associated\n        genealogy tree. The returned graph contains the parents up to\n        *max_depth* variations before this individual. If not provided\n        the maximum depth is up to the begining of the evolution.\n\n        :param individual: The individual at the root of the genealogy tree.\n        :param max_depth: The approximate maximum distance between the root\n                          (individual) and the leaves (parents), optional.\n        :returns: A dictionary where each key is an individual index and the\n                  values are a tuple corresponding to the index of the parents.\n        \"\"\"\n        gtree = {}\n        visited = set()     # Adds memory to the breadth first search\n        def genealogy(index, depth):\n            if index not in self.genealogy_tree:\n                return\n            depth += 1\n            if depth > max_depth:\n                return\n            parent_indices = self.genealogy_tree[index]\n            gtree[index] = parent_indices\n            for ind in parent_indices:\n                if ind not in visited:\n                    genealogy(ind, depth)\n                visited.add(ind)\n        genealogy(individual.history_index, 0)\n        return gtree\n\nclass Statistics(object):\n    \"\"\"Object that compiles statistics on a list of arbitrary objects.\n    When created the statistics object receives a *key* argument that\n    is used to get the values on which the function will be computed.\n    If not provided the *key* argument defaults to the identity function.\n\n    The value returned by the key may be a multi-dimensional object, i.e.:\n    a tuple or a list, as long as the statistical function registered\n    support it. So for example, statistics can be computed directly on\n    multi-objective fitnesses when using numpy statistical function.\n\n    :param key: A function to access the values on which to compute the\n                statistics, optional.\n\n    ::\n\n        >>> import numpy\n        >>> s = Statistics()\n        >>> s.register(\"mean\", numpy.mean)\n        >>> s.register(\"max\", max)\n        >>> s.compile([1, 2, 3, 4])     # doctest: +SKIP\n        {'max': 4, 'mean': 2.5}\n        >>> s.compile([5, 6, 7, 8])     # doctest: +SKIP\n        {'mean': 6.5, 'max': 8}\n    \"\"\"\n    def __init__(self, key=identity):\n        self.key = key\n        self.functions = dict()\n        self.fields = []\n\n    def register(self, name, function, *args, **kargs):\n        \"\"\"Register a *function* that will be applied on the sequence each\n        time :meth:`record` is called.\n\n        :param name: The name of the statistics function as it would appear\n                     in the dictionary of the statistics object.\n        :param function: A function that will compute the desired statistics\n                         on the data as preprocessed by the key.\n        :param argument: One or more argument (and keyword argument) to pass\n                         automatically to the registered function when called,\n                         optional.\n        \"\"\"\n        self.functions[name] = partial(function, *args, **kargs)\n        self.fields.append(name)\n\n    def compile(self, data):\n        \"\"\"Apply to the input sequence *data* each registered function\n        and return the results as a dictionary.\n\n        :param data: Sequence of objects on which the statistics are computed.\n        \"\"\"\n        values = tuple(self.key(elem) for elem in data)\n        entry = dict()\n        for key, func in self.functions.items():\n            entry[key] = func(values)\n        return entry\n\nclass MultiStatistics(dict):\n    \"\"\"Dictionary of :class:`Statistics` object allowing to compute\n    statistics on multiple keys using a single call to :meth:`compile`. It\n    takes a set of key-value pairs associating a statistics object to a\n    unique name. This name can then be used to retrieve the statistics object.\n\n    The following code computes statistics simultaneously on the length and\n    the first value of the provided objects.\n    ::\n\n        >>> from operator import itemgetter\n        >>> import numpy\n        >>> len_stats = Statistics(key=len)\n        >>> itm0_stats = Statistics(key=itemgetter(0))\n        >>> mstats = MultiStatistics(length=len_stats, item=itm0_stats)\n        >>> mstats.register(\"mean\", numpy.mean, axis=0)\n        >>> mstats.register(\"max\", numpy.max, axis=0)\n        >>> mstats.compile([[0.0, 1.0, 1.0, 5.0], [2.0, 5.0]])  # doctest: +SKIP\n        {'length': {'mean': 3.0, 'max': 4}, 'item': {'mean': 1.0, 'max': 2.0}}\n    \"\"\"\n    def compile(self, data):\n        \"\"\"Calls :meth:`Statistics.compile` with *data* of each\n        :class:`Statistics` object.\n\n        :param data: Sequence of objects on which the statistics are computed.\n        \"\"\"\n        record = {}\n        for name, stats in list(self.items()):\n            record[name] = stats.compile(data)\n        return record\n\n    @property\n    def fields(self):\n        return sorted(self.keys())\n\n    def register(self, name, function, *args, **kargs):\n        \"\"\"Register a *function* in each :class:`Statistics` object.\n\n        :param name: The name of the statistics function as it would appear\n                     in the dictionary of the statistics object.\n        :param function: A function that will compute the desired statistics\n                         on the data as preprocessed by the key.\n        :param argument: One or more argument (and keyword argument) to pass\n                         automatically to the registered function when called,\n                         optional.\n        \"\"\"\n        for stats in list(self.values()):\n            stats.register(name, function, *args, **kargs)\n\nclass Logbook(list):\n    \"\"\"Evolution records as a chronological list of dictionaries.\n\n    Data can be retrieved via the :meth:`select` method given the appropriate\n    names.\n\n    The :class:`Logbook` class may also contain other logbooks refered to\n    as chapters. Chapters are used to store information associated to a\n    specific part of the evolution. For example when computing statistics\n    on different components of individuals (namely :class:`MultiStatistics`),\n    chapters can be used to distinguish the average fitness and the average\n    size.\n    \"\"\"\n\n    def __init__(self):\n        self.buffindex = 0\n        self.chapters = defaultdict(Logbook)\n        \"\"\"Dictionary containing the sub-sections of the logbook which are also\n        :class:`Logbook`. Chapters are automatically created when the right hand\n        side of a keyworded argument, provided to the *record* function, is a\n        dictionary. The keyword determines the chapter's name. For example, the\n        following line adds a new chapter \"size\" that will contain the fields\n        \"max\" and \"mean\". ::\n\n            logbook.record(gen=0, size={'max' : 10.0, 'mean' : 7.5})\n\n        To access a specific chapter, use the name of the chapter as a\n        dictionary key. For example, to access the size chapter and select\n        the mean use ::\n\n            logbook.chapters[\"size\"].select(\"mean\")\n\n        Compiling a :class:`MultiStatistics` object returns a dictionary\n        containing dictionnaries, therefore when recording such an object in a\n        logbook using the keyword argument unpacking operator (**), chapters\n        will be automatically added to the logbook.\n        ::\n\n            >>> fit_stats = Statistics(key=attrgetter(\"fitness.values\"))\n            >>> size_stats = Statistics(key=len)\n            >>> mstats = MultiStatistics(fitness=fit_stats, size=size_stats)\n            >>> # [...]\n            >>> record = mstats.compile(population)\n            >>> logbook.record(**record)\n            >>> print(logbook)\n              fitness          length\n            ------------    ------------\n            max     mean    max     mean\n            2       1       4       3\n\n        \"\"\"\n\n        self.columns_len = None\n        self.header = None\n        \"\"\"Order of the columns to print when using the :data:`stream` and\n        :meth:`__str__` methods. The syntax is a single iterable containing\n        string elements. For example, with the previously\n        defined statistics class, one can print the generation and the\n        fitness average, and maximum with\n        ::\n\n            logbook.header = (\"gen\", \"mean\", \"max\")\n\n        If not set the header is built with all fields, in arbritrary order\n        on insertion of the first data. The header can be removed by setting\n        it to :data:`None`.\n        \"\"\"\n\n        self.log_header = True\n        \"\"\"Tells the log book to output or not the header when streaming the\n        first line or getting its entire string representation. This defaults\n        :data:`True`.\n        \"\"\"\n\n    def record(self, **infos):\n        \"\"\"Enter a record of event in the logbook as a list of key-value pairs.\n        The informations are appended chronogically to a list as a dictionary.\n        When the value part of a pair is a dictionary, the informations contained\n        in the dictionary are recorded in a chapter entitled as the name of the\n        key part of the pair. Chapters are also Logbook.\n        \"\"\"\n        apply_to_all = {k: v for k, v in list(infos.items()) if not isinstance(v, dict)}\n        for key, value in list(infos.items()):\n            if isinstance(value, dict):\n                chapter_infos = value.copy()\n                chapter_infos.update(apply_to_all)\n                self.chapters[key].record(**chapter_infos)\n                del infos[key]\n        self.append(infos)\n\n    def select(self, *names):\n        \"\"\"Return a list of values associated to the *names* provided\n        in argument in each dictionary of the Statistics object list.\n        One list per name is returned in order.\n        ::\n\n            >>> log = Logbook()\n            >>> log.record(gen=0, mean=5.4, max=10.0)\n            >>> log.record(gen=1, mean=9.4, max=15.0)\n            >>> log.select(\"mean\")\n            [5.4, 9.4]\n            >>> log.select(\"gen\", \"max\")\n            ([0, 1], [10.0, 15.0])\n\n        With a :class:`MultiStatistics` object, the statistics for each\n        measurement can be retrieved using the :data:`chapters` member :\n        ::\n\n            >>> log = Logbook()\n            >>> log.record(**{'gen': 0, 'fit': {'mean': 0.8, 'max': 1.5},\n            ... 'size': {'mean': 25.4, 'max': 67}})\n            >>> log.record(**{'gen': 1, 'fit': {'mean': 0.95, 'max': 1.7},\n            ... 'size': {'mean': 28.1, 'max': 71}})\n            >>> log.chapters['size'].select(\"mean\")\n            [25.4, 28.1]\n            >>> log.chapters['fit'].select(\"gen\", \"max\")\n            ([0, 1], [1.5, 1.7])\n        \"\"\"\n        if len(names) == 1:\n            return [entry.get(names[0], None) for entry in self]\n        return tuple([entry.get(name, None) for entry in self] for name in names)\n\n    @property\n    def stream(self):\n        \"\"\"Retrieve the formatted not streamed yet entries of the database\n        including the headers.\n        ::\n\n            >>> log = Logbook()\n            >>> log.append({'gen' : 0})\n            >>> print(log.stream)  # doctest: +NORMALIZE_WHITESPACE\n            gen\n            0\n            >>> log.append({'gen' : 1})\n            >>> print(log.stream)  # doctest: +NORMALIZE_WHITESPACE\n            1\n        \"\"\"\n        startindex, self.buffindex = self.buffindex, len(self)\n        return self.__str__(startindex)\n\n    def __delitem__(self, key):\n        if isinstance(key, slice):\n            for i, in range(*key.indices(len(self))):\n                self.pop(i)\n                for chapter in list(self.chapters.values()):\n                    chapter.pop(i)\n        else:\n            self.pop(key)\n            for chapter in list(self.chapters.values()):\n                chapter.pop(key)\n\n    def pop(self, index=0):\n        \"\"\"Retrieve and delete element *index*. The header and stream will be\n        adjusted to follow the modification.\n\n        :param item: The index of the element to remove, optional. It defaults\n                     to the first element.\n\n        You can also use the following syntax to delete elements.\n        ::\n\n            del log[0]\n            del log[1::5]\n        \"\"\"\n        if index < self.buffindex:\n            self.buffindex -= 1\n        return super(self.__class__, self).pop(index)\n\n    def __txt__(self, startindex):\n        columns = self.header\n        if not columns:\n            columns = sorted(self[0].keys()) + sorted(self.chapters.keys())\n        if not self.columns_len or len(self.columns_len) != len(columns):\n            self.columns_len = list(map(len, columns))\n\n        chapters_txt = {}\n        offsets = defaultdict(int)\n        for name, chapter in list(self.chapters.items()):\n            chapters_txt[name] = chapter.__txt__(startindex)\n            if startindex == 0:\n                offsets[name] = len(chapters_txt[name]) - len(self)\n\n        str_matrix = []\n        for i, line in enumerate(self[startindex:]):\n            str_line = []\n            for j, name in enumerate(columns):\n                if name in chapters_txt:\n                    column = chapters_txt[name][i+offsets[name]]\n                else:\n                    value = line.get(name, \"\")\n                    string = \"{0:n}\" if isinstance(value, float) else \"{0}\"\n                    column = string.format(value)\n                self.columns_len[j] = max(self.columns_len[j], len(column))\n                str_line.append(column)\n            str_matrix.append(str_line)\n\n        if startindex == 0 and self.log_header:\n            header = []\n            nlines = 1\n            if len(self.chapters) > 0:\n                nlines += max(list(map(len, list(chapters_txt.values())))) - len(self) + 1\n            header = [[] for i in range(nlines)]\n            for j, name in enumerate(columns):\n                if name in chapters_txt:\n                    length = max(len(line.expandtabs()) for line in chapters_txt[name])\n                    blanks = nlines - 2 - offsets[name]\n                    for i in range(blanks):\n                        header[i].append(\" \" * length)\n                    header[blanks].append(name.center(length))\n                    header[blanks+1].append(\"-\" * length)\n                    for i in range(offsets[name]):\n                        header[blanks+2+i].append(chapters_txt[name][i])\n                else:\n                    length = max(len(line[j].expandtabs()) for line in str_matrix)\n                    for line in header[:-1]:\n                        line.append(\" \" * length)\n                    header[-1].append(name)\n            str_matrix = chain(header, str_matrix)\n\n        template = \"\\t\".join(\"{%i:<%i}\" % (i, l) for i, l in enumerate(self.columns_len))\n        text = [template.format(*line) for line in str_matrix]\n\n        return text\n\n    def __str__(self, startindex=0):\n        text = self.__txt__(startindex)\n        return \"\\n\".join(text)\n\n\nclass HallOfFame(object):\n    \"\"\"The hall of fame contains the best individual that ever lived in the\n    population during the evolution. It is lexicographically sorted at all\n    time so that the first element of the hall of fame is the individual that\n    has the best first fitness value ever seen, according to the weights\n    provided to the fitness at creation time.\n\n    The insertion is made so that old individuals have priority on new\n    individuals. A single copy of each individual is kept at all time, the\n    equivalence between two individuals is made by the operator passed to the\n    *similar* argument.\n\n    :param maxsize: The maximum number of individual to keep in the hall of\n                    fame.\n    :param similar: An equivalence operator between two individuals, optional.\n                    It defaults to operator :func:`operator.eq`.\n\n    The class :class:`HallOfFame` provides an interface similar to a list\n    (without being one completely). It is possible to retrieve its length, to\n    iterate on it forward and backward and to get an item or a slice from it.\n    \"\"\"\n    def __init__(self, maxsize, similar=eq):\n        self.maxsize = maxsize\n        self.keys = list()\n        self.items = list()\n        self.similar = similar\n\n    def update(self, population):\n        \"\"\"Update the hall of fame with the *population* by replacing the\n        worst individuals in it by the best individuals present in\n        *population* (if they are better). The size of the hall of fame is\n        kept constant.\n        \n        :param population: A list of individual with a fitness attribute to\n                           update the hall of fame with.\n        \"\"\"     \n        for ind in population:\n            if len(self) == 0 and self.maxsize !=0:\n                # Working on an empty hall of fame is problematic for the\n                # \"for else\"\n                self.insert(population[0])\n                continue\n\n            if ind.fitness > self[-1].fitness or len(self) < self.maxsize:\n                for hofer in self:\n                    # Loop through the hall of fame to check for any\n                    # similar individual\n                    if self.similar(ind, hofer):\n                        break\n                else:\n                    # The individual is unique and strictly better than\n                    # the worst\n                    if len(self) >= self.maxsize:\n                        self.remove(-1)\n                    self.insert(ind)\n\n    def insert(self, item):\n        \"\"\"Insert a new individual in the hall of fame using the\n        :func:`~bisect.bisect_right` function. The inserted individual is\n        inserted on the right side of an equal individual. Inserting a new\n        individual in the hall of fame also preserve the hall of fame's order.\n        This method **does not** check for the size of the hall of fame, in a\n        way that inserting a new individual in a full hall of fame will not\n        remove the worst individual to maintain a constant size.\n\n        :param item: The individual with a fitness attribute to insert in the\n                     hall of fame.\n        \"\"\"\n        item = deepcopy(item)\n        i = bisect_right(self.keys, item.fitness)\n        self.items.insert(len(self) - i, item)\n        self.keys.insert(i, item.fitness)\n\n    def remove(self, index):\n        \"\"\"Remove the specified *index* from the hall of fame.\n\n        :param index: An integer giving which item to remove.\n        \"\"\"\n        del self.keys[len(self) - (index % len(self) + 1)]\n        del self.items[index]\n\n    def clear(self):\n        \"\"\"Clear the hall of fame.\"\"\"\n        del self.items[:]\n        del self.keys[:]\n\n    def __len__(self):\n        return len(self.items)\n\n    def __getitem__(self, i):\n        return self.items[i]\n\n    def __iter__(self):\n        return iter(self.items)\n\n    def __reversed__(self):\n        return reversed(self.items)\n\n    def __str__(self):\n        return str(self.items)\n\n\nclass ParetoFront(HallOfFame):\n    \"\"\"The Pareto front hall of fame contains all the non-dominated individuals\n    that ever lived in the population. That means that the Pareto front hall of\n    fame can contain an infinity of different individuals.\n\n    :param similar: A function that tels the Pareto front whether or not two\n                    individuals are similar, optional.\n\n    The size of the front may become very large if it is used for example on\n    a continuous function with a continuous domain. In order to limit the number\n    of individuals, it is possible to specify a similarity function that will\n    return :data:`True` if the genotype of two individuals are similar. In that\n    case only one of the two individuals will be added to the hall of fame. By\n    default the similarity function is :func:`operator.eq`.\n\n    Since, the Pareto front hall of fame inherits from the :class:`HallOfFame`,\n    it is sorted lexicographically at every moment.\n    \"\"\"\n    def __init__(self, similar=eq):\n        HallOfFame.__init__(self, None, similar)\n\n    def update(self, population):\n        \"\"\"Update the Pareto front hall of fame with the *population* by adding\n        the individuals from the population that are not dominated by the hall\n        of fame. If any individual in the hall of fame is dominated it is\n        removed.\n\n        :param population: A list of individual with a fitness attribute to\n                           update the hall of fame with.\n        \"\"\"\n        for ind in population:\n            is_dominated = False\n            dominates_one = False\n            has_twin = False\n            to_remove = []\n            for i, hofer in enumerate(self):    # hofer = hall of famer\n                if not dominates_one and hofer.fitness.dominates(ind.fitness):\n                    is_dominated = True\n                    break\n                elif ind.fitness.dominates(hofer.fitness):\n                    dominates_one = True\n                    to_remove.append(i)\n                elif ind.fitness == hofer.fitness and self.similar(ind, hofer):\n                    has_twin = True\n                    break\n\n            for i in reversed(to_remove):       # Remove the dominated hofer\n                self.remove(i)\n            if not is_dominated and not has_twin:\n                self.insert(ind)\n\n__all__ = ['HallOfFame', 'ParetoFront', 'History', 'Statistics', 'MultiStatistics', 'Logbook']\n\nif __name__ == \"__main__\":\n    import doctest\n    from operator import itemgetter\n\n    import numpy\n    doctest.run_docstring_examples(Statistics, globals())\n    doctest.run_docstring_examples(Statistics.register, globals())\n    doctest.run_docstring_examples(Statistics.compile, globals())\n\n    doctest.run_docstring_examples(MultiStatistics, globals())\n    doctest.run_docstring_examples(MultiStatistics.register, globals())\n    doctest.run_docstring_examples(MultiStatistics.compile, globals())\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/deap/tools/support.py b/deap/tools/support.py
--- a/deap/tools/support.py	(revision 9b07e18276b7d69099acd63c4ecf4494b6be638b)
+++ b/deap/tools/support.py	(date 1647452758577)
@@ -554,7 +554,11 @@
         :param item: The individual with a fitness attribute to insert in the
                      hall of fame.
         """
+        # TODO: Modified to copy aggregate fitness attribute
+        # temp = item.fitness.avalue
         item = deepcopy(item)
+        # item.fitness.avalue = temp
+        # print("BEST AGGR = " + str(temp))
         i = bisect_right(self.keys, item.fitness)
         self.items.insert(len(self) - i, item)
         self.keys.insert(i, item.fitness)
